(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{1164:function(t,r,p){t.exports=p.p+"assets/img/image-20231113170949925.95349a3c.jpg"},1325:function(t,r,p){"use strict";p.r(r);var s=p(3),v=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("官方中文文档：")]),t._v(" "),r("p",[t._v("https://springdoc.cn/spring/core.html#aop")])]),t._v(" "),r("h3",{attrs:{id:"aop介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aop介绍"}},[t._v("#")]),t._v(" AOP介绍")]),t._v(" "),r("p",[t._v("AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。\nSpring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。")]),t._v(" "),r("p",[r("img",{attrs:{src:p(1164),alt:"image-20231113170949925"}})]),t._v(" "),r("p",[t._v("图中的implements和extend。即一个是接口，一个是实现类。")]),t._v(" "),r("p",[t._v("当然也可以使用AspectJ，Spring AOP中已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了AOP。")]),t._v(" "),r("h3",{attrs:{id:"spring-aop和aspectj-aop的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop和aspectj-aop的区别"}},[t._v("#")]),t._v(" Spring AOP和AspectJ AOP的区别")]),t._v(" "),r("p",[t._v("Spring AOP是属于运行时增强，而AspectJ是编译时增强。")]),t._v(" "),r("p",[t._v("Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。")]),t._v(" "),r("p",[t._v("Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。")]),t._v(" "),r("p",[t._v("AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。")]),t._v(" "),r("p",[t._v("如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。")]),t._v(" "),r("h3",{attrs:{id:"在spring-aop-中-关注点和横切关注的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在spring-aop-中-关注点和横切关注的区别"}},[t._v("#")]),t._v(" 在Spring AOP 中，关注点和横切关注的区别")]),t._v(" "),r("p",[r("strong",[t._v("关注点")]),t._v("是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。")]),t._v(" "),r("p",[t._v("那什么是"),r("strong",[t._v("连接点")]),t._v("呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。")]),t._v(" "),r("p",[r("strong",[t._v("切入点")]),t._v("是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。")]),t._v(" "),r("h3",{attrs:{id:"通知及通知类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#通知及通知类型"}},[t._v("#")]),t._v(" 通知及通知类型")]),t._v(" "),r("p",[t._v("通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。")]),t._v(" "),r("p",[t._v("Spring切面可以应用五种类型的通知：")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("before")]),t._v("：前置通知，在一个方法执行前被调用。")]),t._v(" "),r("li",[r("strong",[t._v("after")]),t._v(": 在方法执行之后调用的通知，无论方法执行是否成功。")]),t._v(" "),r("li",[r("strong",[t._v("after-returning")]),t._v(": 仅当方法成功完成后执行的通知。")]),t._v(" "),r("li",[r("strong",[t._v("after-throwing")]),t._v(": 在方法抛出异常退出时执行的通知。")]),t._v(" "),r("li",[r("strong",[t._v("around")]),t._v(": 在方法执行之前和之后调用的通知。")])])])}),[],!1,null,null,null);r.default=v.exports}}]);